<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Valou üòª</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600&family=Lora:ital,wght@0,400;1,400&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }

      :root {
        --rose: #e8b4b8;
        --rose-dark: #c97b84;
        --wine: #723d46;
        --cream: #fef9f3;
        --gold: #d4a574;
        --blush: #f5e6e8;
      }

      html,
      body {
        height: 100%;
        height: 100dvh;
        overflow: hidden;
      }

      body {
        font-family: "Lora", Georgia, serif;
        background: linear-gradient(
          160deg,
          #1c1215 0%,
          #2a1f22 50%,
          #1c1215 100%
        );
        display: flex;
        flex-direction: column;
      }

      .screen {
        display: none;
        position: fixed;
        inset: 0;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 1.5rem;
        z-index: 100;
        overflow: hidden;
      }

      .screen.active {
        display: flex;
      }

      #welcome-screen {
        background:
          radial-gradient(
            ellipse at 50% 30%,
            rgba(200, 123, 132, 0.12) 0%,
            transparent 60%
          ),
          linear-gradient(160deg, #1c1215 0%, #2a1f22 100%);
      }

      .welcome-content {
        text-align: center;
        animation: softFadeIn 1.2s ease-out;
      }

      @keyframes softFadeIn {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
      }

      .welcome-icon {
        font-size: 3.5rem;
        margin-bottom: 1.5rem;
        animation: gentlePulse 3s ease-in-out infinite;
      }

      @keyframes gentlePulse {
        0%, 100% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.08); opacity: 0.9; }
      }

      .welcome-title {
        font-family: "Playfair Display", serif;
        font-size: 1.8rem;
        font-weight: 400;
        color: var(--cream);
        margin-bottom: 0.8rem;
        letter-spacing: 0.02em;
      }

      .welcome-sub {
        color: var(--rose);
        font-size: 1rem;
        font-style: italic;
        margin-bottom: 2.5rem;
        line-height: 1.5;
        opacity: 0.9;
      }

      .btn-play {
        background: linear-gradient(135deg, var(--rose-dark) 0%, var(--wine) 100%);
        border: 1px solid rgba(232, 180, 184, 0.3);
        color: var(--cream);
        padding: 1rem 2.5rem;
        font-family: "Lora", serif;
        font-size: 1.1rem;
        border-radius: 40px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 8px 32px rgba(114, 61, 70, 0.4);
      }

      .btn-play:active { transform: scale(0.97); }

      #game-container {
        display: none;
        flex-direction: column;
        width: 100%;
        height: 100%;
        height: 100dvh;
        max-width: 500px;
        margin: 0 auto;
        position: relative;
      }

      #game-container.active { display: flex; }

      .game-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.8rem 1rem;
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        z-index: 10;
      }

      .header-item { text-align: center; }

      .header-label {
        font-size: 0.65rem;
        color: var(--rose);
        text-transform: uppercase;
        letter-spacing: 0.1em;
        margin-bottom: 2px;
      }

      .header-value {
        font-family: "Playfair Display", serif;
        font-size: 1.2rem;
        color: var(--cream);
      }

      .header-value.gold { color: var(--gold); }

      .progress-container {
        padding: 0 1rem 0.5rem;
        background: rgba(0, 0, 0, 0.3);
      }

      .progress-bar {
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--rose-dark), var(--gold));
        border-radius: 2px;
        transition: width 0.3s ease;
        width: 0%;
      }

      #game-canvas {
        flex: 1;
        width: 100%;
        touch-action: none;
      }

      .shooter-area {
        padding: 0.8rem;
        background: linear-gradient(0deg, rgba(0, 0, 0, 0.6) 0%, transparent 100%);
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1.5rem;
      }

      .next-preview {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--rose);
        font-size: 0.8rem;
      }

      .next-bubble-display {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 0.9rem;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .touch-hint {
        color: rgba(255, 255, 255, 0.4);
        font-size: 0.75rem;
        font-style: italic;
      }

      .level-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.9);
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 200;
        animation: fadeIn 0.3s ease;
      }

      .level-overlay.active { display: flex; }

      @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

      .level-complete-content {
        text-align: center;
        animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }

      @keyframes popIn {
        from { transform: scale(0.8); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
      }

      .level-icon { font-size: 3rem; margin-bottom: 1rem; }

      .level-title {
        font-family: "Playfair Display", serif;
        font-size: 1.8rem;
        color: var(--cream);
        margin-bottom: 0.5rem;
      }

      .level-score {
        color: var(--gold);
        font-size: 1.1rem;
        margin-bottom: 1.5rem;
      }

      .level-next {
        color: var(--rose);
        font-size: 0.95rem;
        margin-bottom: 2rem;
        opacity: 0.9;
      }

      .btn-continue {
        background: linear-gradient(135deg, var(--rose-dark), var(--wine));
        border: none;
        color: var(--cream);
        padding: 0.9rem 2rem;
        font-family: "Lora", serif;
        font-size: 1rem;
        border-radius: 30px;
        cursor: pointer;
        transition: transform 0.2s;
      }

      .btn-continue:active { transform: scale(0.95); }

      .game-over-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.9);
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 200;
      }

      .game-over-overlay.active { display: flex; }

      .game-over-content { text-align: center; animation: popIn 0.4s ease; }
      .game-over-icon { font-size: 2.5rem; margin-bottom: 1rem; opacity: 0.8; }

      .game-over-title {
        font-family: "Playfair Display", serif;
        font-size: 1.5rem;
        color: var(--rose);
        margin-bottom: 0.5rem;
      }

      .game-over-score {
        color: var(--cream);
        font-size: 1rem;
        margin-bottom: 2rem;
        opacity: 0.8;
      }

      .btn-retry {
        background: transparent;
        border: 1px solid var(--rose);
        color: var(--rose);
        padding: 0.8rem 2rem;
        font-family: "Lora", serif;
        font-size: 1rem;
        border-radius: 30px;
        cursor: pointer;
        transition: all 0.2s;
      }

      .btn-retry:active { background: var(--rose); color: var(--wine); }

      #valentine-screen {
        background:
          radial-gradient(ellipse at 50% 40%, rgba(200, 123, 132, 0.15) 0%, transparent 60%),
          linear-gradient(160deg, #1c1215 0%, #2a1f22 100%);
      }

      .valentine-content {
        text-align: center;
        max-width: 340px;
        animation: softFadeIn 1s ease-out;
      }

      .valentine-icon {
        font-size: 3rem;
        margin-bottom: 1.5rem;
        animation: gentleFloat 3s ease-in-out infinite;
      }

      @keyframes gentleFloat {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-10px); }
      }

      .valentine-question {
        font-family: "Playfair Display", serif;
        font-size: 1.9rem;
        font-weight: 400;
        color: var(--cream);
        line-height: 1.3;
        margin-bottom: 2.5rem;
      }

      .valentine-buttons {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        align-items: center;
        position: relative;
        min-height: 140px;
      }

      .btn-yes {
        background: linear-gradient(135deg, var(--rose-dark), var(--wine));
        border: none;
        color: var(--cream);
        padding: 1.1rem 3rem;
        font-family: "Playfair Display", serif;
        font-size: 1.3rem;
        border-radius: 40px;
        cursor: pointer;
        box-shadow: 0 8px 32px rgba(114, 61, 70, 0.5);
        transition: all 0.3s ease;
        z-index: 2;
      }

      .btn-yes:active { transform: scale(0.97); }

      .btn-no {
        position: absolute;
        bottom: 0;
        background: transparent;
        border: 1px solid rgba(232, 180, 184, 0.4);
        color: var(--rose);
        padding: 0.7rem 1.8rem;
        font-family: "Lora", serif;
        font-size: 0.95rem;
        border-radius: 30px;
        cursor: pointer;
        transition: all 0.15s ease;
        opacity: 0.7;
      }

      .btn-no.shrinking { animation: shrinkAway 0.3s ease forwards; }

      @keyframes shrinkAway { to { transform: scale(0.7); opacity: 0.4; } }

      .btn-no.tiny { font-size: 0.6rem; padding: 0.3rem 0.8rem; opacity: 0.3; }
      .btn-no.escaped { opacity: 0; pointer-events: none; }

      .no-message {
        position: absolute;
        bottom: -30px;
        color: var(--rose);
        font-size: 0.85rem;
        font-style: italic;
        opacity: 0;
        transition: opacity 0.3s;
      }

      .no-message.visible { opacity: 0.7; }

      #success-screen {
        background-image:
          linear-gradient(rgba(28, 18, 21, 0.85), rgba(28, 18, 21, 0.85)),
          url("IMG_4620.jpeg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
      }

      .success-content {
        text-align: center;
        max-width: 340px;
        animation: softFadeIn 1s ease-out;
      }

      .success-icon { font-size: 2.5rem; margin-bottom: 1.5rem; }

      .success-title {
        font-family: "Playfair Display", serif;
        font-size: 2.2rem;
        font-weight: 400;
        color: var(--cream);
        margin-bottom: 1.5rem;
      }

      .success-message {
        color: var(--rose);
        font-size: 1.05rem;
        line-height: 1.8;
        font-style: italic;
      }

      .success-date {
        margin-top: 2rem;
        padding-top: 1.5rem;
        border-top: 1px solid rgba(232, 180, 184, 0.2);
        color: var(--gold);
        font-size: 0.95rem;
      }

      .particle {
        position: fixed;
        pointer-events: none;
        z-index: 1000;
      }

      .particle.heart { animation: floatUp 4s ease-out forwards; }

      @keyframes floatUp {
        0% { transform: translateY(0) scale(1); opacity: 1; }
        100% { transform: translateY(-100vh) scale(0.5); opacity: 0; }
      }

      .bg-glow {
        position: fixed;
        width: 300px;
        height: 300px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(200, 123, 132, 0.08) 0%, transparent 70%);
        pointer-events: none;
        z-index: 0;
      }

      .bg-glow.one { top: -100px; left: -100px; }
      .bg-glow.two { bottom: -100px; right: -100px; }
    </style>
  </head>
  <body>
    <div class="bg-glow one"></div>
    <div class="bg-glow two"></div>

    <section id="welcome-screen" class="screen active">
      <div class="welcome-content">
        <div class="welcome-icon"></div>
        <h1 class="welcome-title">J'ai quelque chose √† te demander</h1>
        <p class="welcome-sub">
          Mais avant tu dois prouver que t'es <br />
          super forte au jeu des bulles
        </p>
        <button class="btn-play" onclick="startGame()">Commencer</button>
      </div>
    </section>

    <div id="game-container">
      <div class="game-header">
        <div class="header-item">
          <div class="header-label">Score</div>
          <div class="header-value gold" id="score">0</div>
        </div>
        <div class="header-item">
          <div class="header-label">Niveau</div>
          <div class="header-value" id="level">1 / 3</div>
        </div>
        <div class="header-item">
          <div class="header-label">Objectif</div>
          <div class="header-value" id="target">300</div>
        </div>
      </div>
      <div class="progress-container">
        <div class="progress-bar">
          <div class="progress-fill" id="progress-fill"></div>
        </div>
      </div>
      <canvas id="game-canvas"></canvas>
      <div class="shooter-area">
        <div class="next-preview">
          <span>Suivant</span>
          <div class="next-bubble-display" id="next-bubble"></div>
        </div>
        <div class="touch-hint">Touche pour viser et tirer</div>
      </div>
    </div>

    <div class="level-overlay" id="level-overlay">
      <div class="level-complete-content">
        <div class="level-icon">‚ú®</div>
        <h2 class="level-title" id="level-complete-title">Niveau termin√© !</h2>
        <p class="level-score" id="level-complete-score">Score : 300</p>
        <p class="level-next" id="level-complete-next">Niveau 2 sur 3</p>
        <button class="btn-continue" onclick="continueToNextLevel()">Continuer</button>
      </div>
    </div>

    <div class="game-over-overlay" id="game-over">
      <div class="game-over-content">
        <div class="game-over-icon">üí´</div>
        <h2 class="game-over-title">Pas cette fois...</h2>
        <p class="game-over-score">Score : <span id="final-score">0</span></p>
        <button class="btn-retry" onclick="restartGame()">R√©essayer</button>
      </div>
    </div>

    <section id="valentine-screen" class="screen">
      <div class="valentine-content">
        <div class="valentine-icon">üòª‚Äãüòª‚Äãüòª‚Äã</div>
        <h1 class="valentine-question">Veux-tu √™tre ma Valentine ? ü•Ä‚Äã</h1>
        <div class="valentine-buttons">
          <button class="btn-yes" onclick="sayYes()">Oui üòª</button>
          <button class="btn-no" id="btn-no">Non</button>
          <span class="no-message" id="no-message"></span>
        </div>
      </div>
    </section>

    <section id="success-screen" class="screen">
      <div class="success-content">
        <div class="success-icon">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        <h1 class="success-title">Je t'aime</h1>
        <p class="success-message">
          Je sais que c'est pas trop r√©ciproque (fuk),<br />
          mais moi je t'aime prems üòª‚Äã<br />
          t'es ma personne pr√©f√©r√©e <br />
          de la galaxie de la plan√®te <br />
          VOLIM TE<br />
          ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è
        </p>
      </div>
    </section>

    <script>
      const CONFIG = {
        colors: ["#e8b4b8", "#c97b84", "#d4a574", "#a8d5ba", "#b8c5e8"],
        emojis: ["üíó", "üíï", "üå∏", "üçÄ", "üíô"],
        bubbleRadius: 20,
        shootSpeed: 14,
        levels: [
          { target: 300, rows: 5 },
          { target: 500, rows: 6 },
          { target: 700, rows: 7 },
        ],
      };

      let canvas, ctx;
      let dw = 0, dh = 0; // display width/height cached
      let bubbles = [];
      let shooterBubble = null;
      let nextBubbleData = null;
      let shootingBubble = null;
      let aimAngle = -Math.PI / 2;
      let score = 0;
      let levelScore = 0;
      let currentLevel = 0;
      let gameActive = false;
      let canShoot = true;
      let animationId = null;
      let lastTouchPos = null;

      // Pre-rendered bubble canvases for performance
      const bubbleCache = new Map();

      function createBubbleSprite(color, emoji, isShooter) {
        const key = color + emoji + (isShooter ? '1' : '0');
        if (bubbleCache.has(key)) return bubbleCache.get(key);

        const r = CONFIG.bubbleRadius;
        const size = (r + 2) * 2;
        const off = document.createElement('canvas');
        off.width = size;
        off.height = size;
        const octx = off.getContext('2d');

        const cx = size / 2, cy = size / 2;

        // Glow gradient
        const glow = octx.createRadialGradient(cx - r * 0.3, cy - r * 0.3, 0, cx, cy, r);
        glow.addColorStop(0, 'rgba(255,255,255,0.35)');
        glow.addColorStop(0.5, color);
        glow.addColorStop(1, color);

        octx.beginPath();
        octx.arc(cx, cy, r - 1, 0, Math.PI * 2);
        octx.fillStyle = glow;
        octx.fill();

        octx.strokeStyle = isShooter ? 'rgba(255,255,255,0.5)' : 'rgba(255,255,255,0.2)';
        octx.lineWidth = isShooter ? 2 : 1;
        octx.stroke();

        octx.font = `${r * 0.9}px Arial`;
        octx.textAlign = 'center';
        octx.textBaseline = 'middle';
        octx.fillText(emoji, cx, cy + 1);

        bubbleCache.set(key, off);
        return off;
      }

      function clearBubbleCache() {
        bubbleCache.clear();
      }

      function init() {
        canvas = document.getElementById('game-canvas');
        ctx = canvas.getContext('2d');
        setupNoButton();
      }

      function resizeCanvas() {
        const container = document.getElementById('game-container');
        const header = container.querySelector('.game-header');
        const progress = container.querySelector('.progress-container');
        const shooter = container.querySelector('.shooter-area');

        const headerH = header?.offsetHeight || 0;
        const progressH = progress?.offsetHeight || 0;
        const shooterH = shooter?.offsetHeight || 0;

        dw = Math.min(500, window.innerWidth);
        dh = window.innerHeight - headerH - progressH - shooterH;

        // On mobile, skip high-DPI to keep it fast. Use DPR 1.
        // This is the biggest perf win ‚Äî drawing fewer pixels.
        canvas.width = dw;
        canvas.height = dh;
        canvas.style.width = dw + 'px';
        canvas.style.height = dh + 'px';

        CONFIG.bubbleRadius = Math.min(20, Math.floor(dw / 22));
        clearBubbleCache(); // radius may have changed
      }

      function startGame() {
        document.getElementById('welcome-screen').classList.remove('active');
        document.getElementById('game-container').classList.add('active');

        setTimeout(() => {
          resizeCanvas();
          window.addEventListener('resize', () => {
            resizeCanvas();
            if (gameActive) render();
          });
          initLevel();
        }, 50);
      }

      function initLevel() {
        const levelConfig = CONFIG.levels[currentLevel];
        bubbles = [];
        levelScore = 0;
        shootingBubble = null;
        canShoot = true;
        gameActive = true;

        createBubbleGrid(levelConfig.rows);
        createShooterBubble();
        setupControls();
        updateUI();
        gameLoop();
      }

      function showLevelComplete() {
        gameActive = false;
        if (animationId) cancelAnimationFrame(animationId);

        const isLast = currentLevel >= CONFIG.levels.length - 1;

        document.getElementById('level-complete-title').textContent =
          isLast ? 'Bravo üòª‚Äã' : 'Niveau termin√© üòª‚Äã ';
        document.getElementById('level-complete-score').textContent =
          'Score : ' + score;
        document.getElementById('level-complete-next').textContent = isLast
          ? 'Tu as gagn√© üòª‚Äã'
          : 'Niveau ' + (currentLevel + 2) + ' sur 3';
        document.querySelector('#level-overlay .btn-continue').textContent =
          isLast ? 'D√©couvrir' : 'Continuer';

        document.getElementById('level-overlay').classList.add('active');
      }

      function continueToNextLevel() {
        document.getElementById('level-overlay').classList.remove('active');
        if (currentLevel >= CONFIG.levels.length - 1) {
          showValentineScreen();
        } else {
          currentLevel++;
          setTimeout(initLevel, 300);
        }
      }

      function restartGame() {
        document.getElementById('game-over').classList.remove('active');
        score = Math.max(0, score - levelScore);
        levelScore = 0;
        initLevel();
      }

      function showValentineScreen() {
        document.getElementById('game-container').classList.remove('active');
        document.getElementById('valentine-screen').classList.add('active');
      }

      function sayYes() {
        document.getElementById('valentine-screen').classList.remove('active');
        document.getElementById('success-screen').classList.add('active');
        createHeartParticles();
      }

      // ============== NO BUTTON ==============
      function setupNoButton() {
        const btn = document.getElementById('btn-no');
        const msg = document.getElementById('no-message');
        let attempts = 0;

        const messages = [
          "pourquoi tu clic la ?", "wtf quoi", "tu continues en plus",
          "pq tu continues", "fuk you", "‚Äãüò°‚Äã", "‚Äãüò°‚Äã‚Äãüò°‚Äã‚Äãüò°‚Äã",
        ];

        const handleNo = (e) => {
          e.preventDefault();
          e.stopPropagation();
          attempts++;

          msg.textContent = messages[Math.min(attempts - 1, messages.length - 1)];
          msg.classList.add('visible');

          if (attempts <= 3) {
            const container = btn.parentElement;
            const maxX = container.offsetWidth / 2 - btn.offsetWidth / 2 - 10;
            const x = (Math.random() - 0.5) * maxX * 2;
            const y = Math.random() * 60;
            btn.style.transform = 'translate(' + x + 'px, ' + y + 'px)';
          } else if (attempts <= 5) {
            btn.classList.add('shrinking');
            const scale = 1 - (attempts - 3) * 0.25;
            btn.style.transform = 'scale(' + scale + ')';
          } else if (attempts === 6) {
            btn.classList.add('tiny');
            btn.textContent = 'non';
            btn.style.transform = 'scale(0.6)';
          } else {
            btn.classList.add('escaped');
            msg.textContent = 'tu peux plus FUK üñï‚Äã';
          }
        };

        btn.addEventListener('click', handleNo);
        btn.addEventListener('touchstart', handleNo, { passive: false });

        btn.addEventListener('mouseenter', () => {
          if (attempts > 0 && attempts < 4) {
            const container = btn.parentElement;
            const maxX = container.offsetWidth / 2 - btn.offsetWidth / 2 - 10;
            const x = (Math.random() - 0.5) * maxX * 2;
            const y = Math.random() * 50;
            btn.style.transform = 'translate(' + x + 'px, ' + y + 'px)';
          }
        });
      }

      // ============== PARTICLES ==============
      function createHeartParticles() {
        const hearts = ['‚ô•', 'üíï', 'üíó', '‚ú®'];
        for (let i = 0; i < 20; i++) {
          setTimeout(() => {
            const p = document.createElement('div');
            p.className = 'particle heart';
            p.textContent = hearts[Math.floor(Math.random() * hearts.length)];
            p.style.left = Math.random() * 100 + 'vw';
            p.style.bottom = '0';
            p.style.fontSize = Math.random() * 1.5 + 1 + 'rem';
            p.style.animationDuration = Math.random() * 2 + 3 + 's';
            document.body.appendChild(p);
            setTimeout(() => p.remove(), 5000);
          }, i * 150);
        }
      }

      // ============== BUBBLE GRID ==============
      function createBubbleGrid(rows) {
        const cols = Math.floor(dw / (CONFIG.bubbleRadius * 2));
        for (let row = 0; row < rows; row++) {
          const isOffset = row % 2 === 1;
          const actualCols = isOffset ? cols - 1 : cols;
          for (let col = 0; col < actualCols; col++) {
            const offset = isOffset ? CONFIG.bubbleRadius : 0;
            const x = col * CONFIG.bubbleRadius * 2 + CONFIG.bubbleRadius + offset;
            const y = row * CONFIG.bubbleRadius * 1.73 + CONFIG.bubbleRadius;
            const ci = Math.floor(Math.random() * CONFIG.colors.length);
            bubbles.push({
              x, y,
              color: CONFIG.colors[ci],
              emoji: CONFIG.emojis[ci],
              colorIndex: ci,
            });
          }
        }
      }

      function createShooterBubble() {
        if (nextBubbleData) {
          shooterBubble = {
            x: dw / 2,
            y: dh - 35,
            ...nextBubbleData,
          };
        } else {
          const ci = Math.floor(Math.random() * CONFIG.colors.length);
          shooterBubble = {
            x: dw / 2,
            y: dh - 35,
            color: CONFIG.colors[ci],
            emoji: CONFIG.emojis[ci],
            colorIndex: ci,
          };
        }

        const ni = Math.floor(Math.random() * CONFIG.colors.length);
        nextBubbleData = {
          color: CONFIG.colors[ni],
          emoji: CONFIG.emojis[ni],
          colorIndex: ni,
        };
        updateNextBubbleDisplay();
      }

      function updateNextBubbleDisplay() {
        const d = document.getElementById('next-bubble');
        d.style.background = nextBubbleData.color;
        d.textContent = nextBubbleData.emoji;
      }

      // ============== CONTROLS ==============
      function setupControls() {
        canvas.removeEventListener('touchstart', handleTouchStart);
        canvas.removeEventListener('touchmove', handleTouchMove);
        canvas.removeEventListener('touchend', handleTouchEnd);
        canvas.removeEventListener('mousemove', handleMouseMove);
        canvas.removeEventListener('click', handleClick);

        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('click', handleClick);
      }

      function handleTouchStart(e) {
        e.preventDefault();
        lastTouchPos = getTouchPos(e.touches[0]);
        updateAim(lastTouchPos.x, lastTouchPos.y);
      }

      function handleTouchMove(e) {
        e.preventDefault();
        lastTouchPos = getTouchPos(e.touches[0]);
        updateAim(lastTouchPos.x, lastTouchPos.y);
      }

      function handleTouchEnd(e) {
        e.preventDefault();
        if (lastTouchPos) shoot();
        lastTouchPos = null;
      }

      function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        updateAim(e.clientX - rect.left, e.clientY - rect.top);
      }

      function handleClick() { shoot(); }

      function getTouchPos(touch) {
        const rect = canvas.getBoundingClientRect();
        return { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
      }

      function updateAim(x, y) {
        if (!shooterBubble || !gameActive) return;
        aimAngle = Math.atan2(y - shooterBubble.y, x - shooterBubble.x);
        aimAngle = Math.max(-Math.PI + 0.25, Math.min(-0.25, aimAngle));
      }

      function shoot() {
        if (!gameActive || !canShoot || shootingBubble || !shooterBubble) return;
        canShoot = false;
        shootingBubble = {
          ...shooterBubble,
          vx: Math.cos(aimAngle) * CONFIG.shootSpeed,
          vy: Math.sin(aimAngle) * CONFIG.shootSpeed,
        };
        shooterBubble = null;
      }

      // ============== GAME LOOP ==============
      function gameLoop() {
        if (!gameActive) return;
        update();
        render();
        animationId = requestAnimationFrame(gameLoop);
      }

      function update() {
        if (!shootingBubble) return;

        shootingBubble.x += shootingBubble.vx;
        shootingBubble.y += shootingBubble.vy;

        if (shootingBubble.x <= CONFIG.bubbleRadius) {
          shootingBubble.x = CONFIG.bubbleRadius;
          shootingBubble.vx *= -1;
        } else if (shootingBubble.x >= dw - CONFIG.bubbleRadius) {
          shootingBubble.x = dw - CONFIG.bubbleRadius;
          shootingBubble.vx *= -1;
        }

        if (shootingBubble.y <= CONFIG.bubbleRadius) {
          snapBubble();
          return;
        }

        const r19 = CONFIG.bubbleRadius * 1.9;
        for (let i = 0; i < bubbles.length; i++) {
          const b = bubbles[i];
          const dx = shootingBubble.x - b.x;
          const dy = shootingBubble.y - b.y;
          if (dx * dx + dy * dy < r19 * r19) {
            snapBubble();
            return;
          }
        }
      }

      function snapBubble() {
        const row = Math.max(0, Math.round(
          (shootingBubble.y - CONFIG.bubbleRadius) / (CONFIG.bubbleRadius * 1.73)
        ));
        const isOffset = row % 2 === 1;
        const offset = isOffset ? CONFIG.bubbleRadius : 0;
        const col = Math.round(
          (shootingBubble.x - CONFIG.bubbleRadius - offset) / (CONFIG.bubbleRadius * 2)
        );

        const snappedX = col * CONFIG.bubbleRadius * 2 + CONFIG.bubbleRadius + offset;
        const snappedY = row * CONFIG.bubbleRadius * 1.73 + CONFIG.bubbleRadius;

        const newBubble = {
          x: Math.max(CONFIG.bubbleRadius, Math.min(dw - CONFIG.bubbleRadius, snappedX)),
          y: Math.max(CONFIG.bubbleRadius, snappedY),
          color: shootingBubble.color,
          emoji: shootingBubble.emoji,
          colorIndex: shootingBubble.colorIndex,
        };

        bubbles.push(newBubble);

        const matches = findMatches(newBubble);

        if (matches.length >= 3) {
          for (let i = matches.length - 1; i >= 0; i--) {
            const idx = bubbles.indexOf(matches[i]);
            if (idx > -1) bubbles.splice(idx, 1);
          }

          const matchScore = matches.length * 15;
          const floating = findFloating();

          for (let i = floating.length - 1; i >= 0; i--) {
            const idx = bubbles.indexOf(floating[i]);
            if (idx > -1) bubbles.splice(idx, 1);
          }

          const totalGain = matchScore + floating.length * 25;
          score += totalGain;
          levelScore += totalGain;
          updateUI();

          if (levelScore >= CONFIG.levels[currentLevel].target || bubbles.length === 0) {
            setTimeout(showLevelComplete, 400);
            shootingBubble = null;
            return;
          }
        }

        let maxY = 0;
        for (let i = 0; i < bubbles.length; i++) {
          if (bubbles[i].y > maxY) maxY = bubbles[i].y;
        }
        if (maxY > dh - 80) {
          gameActive = false;
          document.getElementById('final-score').textContent = score;
          document.getElementById('game-over').classList.add('active');
          shootingBubble = null;
          return;
        }

        shootingBubble = null;
        createShooterBubble();
        setTimeout(() => { canShoot = true; }, 150);
      }

      function findMatches(start) {
        const matches = [start];
        const checked = new Set();
        const queue = [start];
        const r23sq = (CONFIG.bubbleRadius * 2.3) ** 2;

        while (queue.length > 0) {
          const current = queue.shift();
          const key = (current.x | 0) + ',' + (current.y | 0);
          if (checked.has(key)) continue;
          checked.add(key);

          for (let i = 0; i < bubbles.length; i++) {
            const b = bubbles[i];
            if (b === current || b.colorIndex !== start.colorIndex) continue;
            const dx = current.x - b.x;
            const dy = current.y - b.y;
            if (dx * dx + dy * dy < r23sq) {
              const bKey = (b.x | 0) + ',' + (b.y | 0);
              if (!checked.has(bKey) && matches.indexOf(b) === -1) {
                matches.push(b);
                queue.push(b);
              }
            }
          }
        }
        return matches;
      }

      function findFloating() {
        const connected = new Set();
        const r23sq = (CONFIG.bubbleRadius * 2.3) ** 2;
        const topThresh = CONFIG.bubbleRadius * 2;

        for (let i = 0; i < bubbles.length; i++) {
          if (bubbles[i].y < topThresh) connected.add(bubbles[i]);
        }

        let changed = true;
        while (changed) {
          changed = false;
          for (let i = 0; i < bubbles.length; i++) {
            const b = bubbles[i];
            if (connected.has(b)) continue;
            for (const conn of connected) {
              const dx = b.x - conn.x;
              const dy = b.y - conn.y;
              if (dx * dx + dy * dy < r23sq) {
                connected.add(b);
                changed = true;
                break;
              }
            }
          }
        }
        return bubbles.filter(b => !connected.has(b));
      }

      function updateUI() {
        document.getElementById('score').textContent = score;
        document.getElementById('level').textContent = (currentLevel + 1) + ' / 3';
        document.getElementById('target').textContent = CONFIG.levels[currentLevel].target;
        const progress = Math.min(100, (levelScore / CONFIG.levels[currentLevel].target) * 100);
        document.getElementById('progress-fill').style.width = progress + '%';
      }

      // ============== RENDER ==============
      function render() {
        ctx.clearRect(0, 0, dw, dh);

        // Danger line
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(200, 100, 100, 0.25)';
        ctx.lineWidth = 1;
        ctx.setLineDash([8, 8]);
        ctx.moveTo(0, dh - 80);
        ctx.lineTo(dw, dh - 80);
        ctx.stroke();
        ctx.setLineDash([]);

        // Grid bubbles ‚Äî use cached sprites
        for (let i = 0; i < bubbles.length; i++) {
          drawBubbleFast(bubbles[i], false);
        }

        if (shootingBubble) {
          drawBubbleFast(shootingBubble, false);
        }

        if (shooterBubble && !shootingBubble) {
          // Aim dots
          ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
          for (let i = 1; i <= 8; i++) {
            const d = i * 25;
            const x = shooterBubble.x + Math.cos(aimAngle) * d;
            const y = shooterBubble.y + Math.sin(aimAngle) * d;
            if (y < shooterBubble.y - 10) {
              ctx.beginPath();
              ctx.arc(x, y, 3, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          drawBubbleFast(shooterBubble, true);
        }
      }

      function drawBubbleFast(bubble, isShooter) {
        const sprite = createBubbleSprite(bubble.color, bubble.emoji, isShooter);
        const r = CONFIG.bubbleRadius;
        ctx.drawImage(sprite, bubble.x - r - 2, bubble.y - r - 2);
      }

      window.onload = init;
    </script>
  </body>
</html>
